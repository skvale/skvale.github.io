{"pageProps":{"post":{"title":"I increased the speed of my requests by 1000x","date":"2021-05-21T05:35:07.322Z","slug":"mocking-for-development","content":"<p>I should clarify that this is all from the perspective of local development.</p>\n<h2>I'm primarily a frontend engineer</h2>\n<p>In my new job, requests to a development server were taking about 12 - 20 seconds. Originally I noticed that 90% of the requests were the same response so I decided to return mocked data.</p>\n<h2>MSW success</h2>\n<p>Using mock-service-worker worked well. I saw requests to mocks coming back in 20ms, but it opened up a lot more ideas as well. I could switch any data I want from my APIs. I could see what any error conditions looked like. I could reproduce a bug from a race condition of response order. I could develop against responses that weren't finished in the backend yet.</p>\n<p>This seemed like a great idea to build out further because it could make other engineers more efficient and enjoy their jobs more.</p>\n<h2>Make it less complex</h2>\n<p>We need to cut out unnecessary complexity in development environments. Not in a sense that it's a nice thing to do, but that software systems struggle to grow without removing complexity where it doesn't belong.</p>\n<p>I removed other external dependencies in local development. Now I have an http-server serving an HTMLWebpackPlugin generated file which includes the JavaScript, CSS, and fonts.</p>\n<p>I can work without WiFi, which is saying a lot when before there was an orchestration of Docker containers and Ruby apps.</p>\n<p>When I want to do UI development, I can focus on the generated JavaScript/CSS bundles communicating via API requests. I can modify the JavaScript to behave differently given certain responses.</p>\n<p>If I still want the broader integration, it isn't far away, but the simplicity of JS talking to a controlled API at lightning speed is a delightful experience.</p>\n<h2>Is the mocked data valid</h2>\n<p>Pretty soon I had a lot of JSON locally. For the majority of my use cases I want a snapshot of \"real\" data, so I created a script to generate the mocks from a web archive (<code>.har</code>) file. The generated mocks are disposable so they don't need to be kept up to date.</p>\n<p>I also created bare bones mocks and utility functions to modify the mocked data. Changes in the API can happen within 1 function instead of many instances of mocks.</p>\n<p>If you're using GraphQL the mocks can be made to match types generated from the schema. If you're using REST endpoints you could validate against OpenAPI schemas, if they exist.</p>\n<h2>Modify it anywhere</h2>\n<p>To increase visibility and ease of access I extended mock-service-worker to store the mocks as a global object, say <code>window.MOCKS</code>. Requests come into mock-service-worker and it looks at the global object to see if it has a request to respond with. The mocked requests and available utils are available like</p>\n<pre><code class=\"language-js\">window.MOCKS = {\n  GET: {\n    '/your/endpoint': {json: {}, delay: 0, status: 200},\n    ...\n  },\n  POST: {},\n  ...,\n  utils: { modifyEndpoint: fn, ... }\n}\n</code></pre>\n<p>This allows consumers to modify the global object any time before a request is made. Customizations could happen in a script tag in the HTML.</p>\n<p>I've also used query parameters to toggle common things, like feature flags, permissions, configuration modes, and base mocks. It's a pleasant experience to modify the URL and refresh to see changes.</p>\n<p>Some caveats: The path can be dynamic with path params and the response can be function of the request, context, and path params.</p>\n<h2>Fast, predictable browser tests</h2>\n<p>The same tool can be used for automated browser tests (Cypress, Puppeteer, etc). Tests have many possible states that are stored in the test files as calls to utility functions. We're able to copy-paste the modifications, or parts of them, into our development sandboxes and create new features.</p>\n<h2>Make it easy to use</h2>\n<p>The most difficult thing has been encouraging people to use it and see its value. As a new engineer on a team, I'm sensitive to shaking up the way things have been done. The ergonomics of use needed to be seamless and simple. There are 2 npm scripts. One to compile the JS and generate the dev HTML and another to start an http-server.</p>\n<h2>Backend paradigm shift</h2>\n<p>As with most decisions, there are unintended cultural consequences. This strategy has created more distance between UI engineers from the backend.</p>\n<p>In development we're typically finding issues with the API and helping track down which configuration caused it. When the API is mocked, the backend isn't touched and these issues aren't found.</p>\n<p>The attention shifts from looking at the backend as an extension of the UI to a service that responds to HTTP requests. This is a more appropriate boundary as apps grow, but may not be seen favorably on a smaller project.</p>\n"}},"__N_SSG":true}